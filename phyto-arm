#!/usr/bin/env python3
'''
This script is used to launch the PhytO-ARM software.

It reads the system configuration from the provided config file and starts the
ROS2 nodes with the appropriate settings.

The nodes are mostly started by ros2 launch, with the notable exception of
`ros2 bag record`, which we want to keep recording at all costs.
'''
import argparse
import atexit
import json
import os
import shlex
import subprocess
import sys
import tempfile
import urllib.request

import yaml

from yaml_validator import validate_config


def flatten_dict(d, parent_key='', sep='.'):
    """Flatten a nested dictionary using dot-separated keys."""
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep).items())
        else:
            items.append((new_key, v))
    return dict(items)


def convert_to_ros2_params(config):
    """
    Convert ROS1-style YAML config to ROS2 parameter format.

    ROS1 uses nested dicts with slash hierarchy:
        winch:
          range:
            min: 0.7

    ROS2 expects:
        /**:
          ros__parameters:
            winch.range.min: 0.7
    """
    flat_params = flatten_dict(config)

    # Filter out None values and unsupported types
    filtered_params = {}
    for k, v in flat_params.items():
        if v is None:
            continue
        # ROS2 parameters support: bool, int, float, str, and homogeneous lists
        if isinstance(v, (bool, int, float, str)):
            filtered_params[k] = v
        elif isinstance(v, list) and len(v) > 0:
            # Check if list is homogeneous and of supported types
            first_type = type(v[0])
            if first_type in (bool, int, float, str) and all(isinstance(x, first_type) for x in v):
                filtered_params[k] = v

    # Wrap in ROS2 parameter format
    return {'/**': {'ros__parameters': filtered_params}}


# Prepare a command and environment for ros2 launch
def prep_ros2_launch(args, config, env, package, launchfile, params_file=None):
    # Build the command-line arguments for ros2 launch
    rl_args = ['ros2', 'launch', package, launchfile]
    rl_args.append(f'config_file:={os.path.abspath(args.config)}')

    for launch_arg, value in config.get('launch_args', {}).items():
        rl_args.append(f'{launch_arg}:={value}')

    # Pass the ROS2 params file if provided
    if params_file is not None:
        rl_args.append(f'params_file:={params_file}')

    # Build the command to invoke as an escaped string
    command = ' '.join(shlex.quote(a) for a in rl_args)
    return command, env


# Send alerts when the program stops
def send_alerts(alert_config, deployment, launch_name):
    for alert in alert_config:
        assert alert['type'] == 'slack' and alert['url']
        urllib.request.urlopen(
            alert['url'],
            json.dumps({
                'text': f'*PhytO-ARM process stopped*\n - Deployment: _{deployment}_ \n - Process: _{launch_name}_'
            }).encode()
        )


def start(args):
    # Validate config file
    if not args.skip_validation:
        print(f'Validating config file {args.config} against {args.config_schema}...')
        if validate_config(args.config, args.config_schema):
            print('Config file is valid')
        else:
            sys.exit(1)

    # Load the config file
    with open(args.config, 'rb') as f:
        config = yaml.safe_load(f)

    # Convert to ROS2 parameter format and write to temp file
    ros2_params = convert_to_ros2_params(config)
    params_file = tempfile.NamedTemporaryFile(
        mode='w', suffix='.yaml', prefix='ros2_params_', delete=False
    )
    yaml.dump(ros2_params, params_file)
    params_file.close()
    atexit.register(lambda: os.unlink(params_file.name))
    print(f'Converted config to ROS2 params: {params_file.name}')

    # Prepare the environment
    env = dict(os.environ)

    # Define an atexit handler that can be used to terminate subprocesses.
    def cleanup(name, proc, dont_kill=False):
        if proc.returncode is not None:  # already dead
            return

        try:
            print(f'terminating {name} ({proc.pid})')
            proc.terminate()
            proc.wait(5.0)
        except subprocess.TimeoutExpired:
            if dont_kill:
                print(f'failed to terminate {name} ({proc.pid}), '
                        'but refusing to kill')
            else:
                print(f'failed to terminate {name} ({proc.pid}), killing')
                proc.kill()

            proc.wait()
            print(f'{name} ({proc.pid}) eventually exited')

    # Set up alerts for when we terminate
    atexit.register(send_alerts, config.get('alerts', []), config.get('name'), args.launch_name)

    # Allow the config to override where logs are stored
    log_dir = config.get('launch_args', {}).get('log_dir')
    if log_dir is not None:
        env['ROS_LOG_DIR'] = log_dir

    # The following should only launch once, with the main PhytO-ARM processes
    rosbag = None
    if args.launch_name == "main":
        # Start the rosbag logging process. We run this separately from the main
        # launch file so that if the main nodes crash, we don't terminate the rosbag
        # prematurely.
        command, env = prep_ros2_launch(args, config, env, 'phyto_arm', 'rosbag.launch.xml')
        rosbag = subprocess.Popen(command, shell=True, env=env)
        atexit.register(lambda: cleanup('rosbag record', rosbag, dont_kill=True))

    # Prepare our ros2 launch command
    command, env = prep_ros2_launch(args, config, env, 'phyto_arm', f'{args.launch_name}.launch.xml', params_file.name)
    nodes = subprocess.Popen(command, shell=True, env=env)
    atexit.register(lambda: cleanup('nodes', nodes))

    # Wait for any child to terminate
    pid, status = os.wait()

    # Since we called wait() behind subprocess's back, we need to inform it that
    # the process terminated. A little hacky.
    for proc in [rosbag, nodes]:
        if proc is not None and proc.pid == pid:
            proc.returncode = os.WEXITSTATUS(status) \
                              if os.WIFEXITED(status) else -1

    # The atexit handlers will terminate the other subprocesses
    pass


if __name__ == '__main__':
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description=__doc__)
    subparsers = parser.add_subparsers(dest='command', required=True)

    start_parser = subparsers.add_parser('start')
    start_parser.add_argument('launch_name')
    start_parser.add_argument('config')
    start_parser.add_argument('--config_schema', default='./configs/example.yaml')
    start_parser.add_argument('--skip_validation', action='store_true')

    args = parser.parse_args()

    # Invoke the handler for this subcommand
    {
        'start': start,
    }[args.command](args)
