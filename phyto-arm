#!/usr/bin/env python3
import argparse
import atexit
import json
import os
import sys
import urllib.request
from pathlib import Path

import docker
import yaml

from scripts.config_validation import validate_config

def create_network(client):
    """Create or get the Docker network for PhytO-ARM containers"""
    try:
        return client.networks.get("phyto-arm-net")
    except docker.errors.NotFound:
        return client.networks.create("phyto-arm-net", driver="bridge")

def start_container(client, image_name, network_name, config_path: str, name: str, process_config: dict) -> docker.models.containers.Container:
    container_name = f"phyto-arm-{name}"
    
    # Base volumes that all containers need
    volumes = {
        str(Path(config_path).absolute()): {
            "bind": "/app/mounted_config.yaml",
            "mode": "ro"
        },
        str(Path("configs").absolute()): {
            "bind": "/app/configs",
            "mode": "ro"
        }
    }
    
    # Convert launch args to roslaunch arguments
    launch_args = []
    for key, value in process_config.get('launch_args', {}).items():
        launch_args.append(f"{key}:={value}")
    launch_args_str = " ".join(launch_args)

    # Convert paths to volumes and add to launch args
    for vol_name, host_path in process_config.get('volumes', {}).items():
        if vol_name in launch_args:
            raise ValueError(f"Volume name cannot be the same as a launch arg: {vol_name}")

        # Ensure the host directory exists
        Path(host_path).mkdir(parents=True, exist_ok=True)

        # Mount within '/app/volumes' in the container
        mounted_path = f"/app/volumes/{vol_name}"
        volumes[host_path] = {"bind": mounted_path, "mode": "rw"}

        # Add the volume to the launch args
        launch_args.append(f"{vol_name}:={mounted_path}")

    # Likewise, check for devices, mount them, and add to launch args
    devices = []
    for device_name, host_path in process_config.get('devices', {}).items():
        if device_name in launch_args:
            raise ValueError(f"Device name cannot be the same as a launch arg: {device_name}")
        # Maintain the host path
        devices.append(f"{host_path}:{host_path}:r")
        launch_args.append(f"{device_name}:={host_path}")

    # And add udp ports
    ports = []
    for port_name, port_value in process_config.get('udp_ports', {}).items():
        if port_name in launch_args:
            raise ValueError(f"UDP port name cannot be the same as a launch arg: {port_name}")
        ports.append(f"{port_name}:{port_value}/udp")
        launch_args.append(f"{port_name}:={port_value}")

    # Add tcp ports
    for port_name, port_value in process_config.get('tcp_ports', {}).items():
        if port_name in launch_args:
            raise ValueError(f"TCP port name cannot be the same as a launch arg: {port_name}")
        ports.append(f"{port_name}:{port_value}/tcp")
        launch_args.append(f"{port_name}:={port_value}")

    # Build the roslaunch command based on container type
    if name == "main":
        command = f"""bash -c "
            source devel/setup.bash &&
            roscore &
            sleep 5 &&
            roslaunch --wait phyto_arm rosbag.launch config_file:=/app/mounted_config.yaml {launch_args_str} &&
            roslaunch --wait phyto_arm main.launch config_file:=/app/mounted_config.yaml {launch_args_str}
        " """
    else:
        command = f"""bash -c "
            source devel/setup.bash &&
            roslaunch --wait phyto_arm {name}.launch config_file:=/app/mounted_config.yaml {launch_args_str}
        " """

    # Base container configuration
    container_config = {
        "image": image_name,
        "name": container_name,
        "command": command,
        "detach": True,
        "remove": True,
        "volumes": volumes,
        "network": network_name,
        "devices": devices,
        "ports": ports,
        "environment": {
            "ROS_MASTER_URI": "http://phyto-arm-main:11311"  # Point to main container
        }
    }

    if name == "main":
        # Main container doesn't need ROS_MASTER_URI
        container_config["environment"] = {}

    # Start the container
    try:
        container = client.containers.run(**container_config)
        print(f"Started container {container_name}")
        return container
    except docker.errors.APIError as e:
        print(f"Failed to start container {container_name}: {e}")
        raise

def stop_container(container) -> None:
    try:
        container.stop()
        print(f"Stopped container {container.name}")
    except docker.errors.APIError as e:
        print(f"Failed to stop container {container.name}: {e}")

def send_alerts(config) -> None:
    """Send alerts when stopping the system"""
    for alert in config.get('alerts', []):
        if alert['type'] == 'slack' and alert.get('url'):
            try:
                urllib.request.urlopen(
                    alert['url'],
                    json.dumps({
                        'text': f'*PhytO-ARM process stopped*\n - Deployment: _{config.get("name", "unknown")}_ \n'
                    }).encode()
                )
            except Exception as e:
                print(f"Failed to send alert: {e}")

def start(args):
    client = docker.from_env()
    network = create_network(client)
    
    with open(args.config, 'r') as f:
        config = yaml.safe_load(f)
    
    # Validate config
    if not args.skip_validation:
        print(f'Validating config file {args.config} against {args.config_schema}...')
        if not validate_config(args.config, args.config_schema):
            sys.exit(1)
    
    image_name = config['docker']['image']
    containers = {}
    
    def cleanup():
        for container in containers.values():
            stop_container(container)
        try:
            network.remove()
        except docker.errors.APIError:
            pass
        send_alerts(config)
    
    # Register cleanup on exit
    atexit.register(cleanup)
    
    # Start main container first
    main_process = config['processes'].get('main', None)
    if main_process and main_process.get('enabled', True):
        containers['main'] = start_container(client, image_name, network.name, args.config, 'main', main_process)
    else:
        print("Main process not found or not enabled in config")
        sys.exit(1)

    # Give main container time to start roscore
    print("Waiting for main container to start...")
    import time
    time.sleep(10)

    # Start other enabled processes
    for process_name, process_args in config['processes'].items():
        if process_name != 'main' and process_args.get('enabled', True):
            containers[process_name] = start_container(client, image_name, network.name, args.config, process_name, process_args)

def stop():
    client = docker.from_env()
    containers = client.containers.list(filters={"name": "phyto-arm-"})

    if not containers:
        print("No running PhytO-ARM containers found")
        return

    # If no specific container specified, stop all
    for container in containers:
        stop_container(container)

def attach(args):
    client = docker.from_env()
    containers = client.containers.list(filters={"name": "phyto-arm-"})

    if not containers:
        print("No running PhytO-ARM containers found")
        return

    # If no specific container specified, attach to main
    container_name = f"phyto-arm-{args.name}" if args.name else "phyto-arm-main"

    # Find the requested container
    container = next((c for c in containers if c.name == container_name), None)
    if not container:
        print(f"Container {container_name} not found")
        return

    # Attach to the container
    os.system(f"docker attach {container.id}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)
    subparsers = parser.add_subparsers(dest='command', required=True)

    # Start command
    start_parser = subparsers.add_parser('start')
    start_parser.add_argument('config')
    start_parser.add_argument('--config_schema', default='./configs/example.yaml')
    start_parser.add_argument('--skip_validation', action='store_true')

    # Stop command
    stop_parser = subparsers.add_parser('stop')
    stop_parser.add_argument('config')

    # Attach command
    attach_parser = subparsers.add_parser('attach')
    attach_parser.add_argument('name', nargs='?', help='Container name to attach to (defaults to main)')

    parsed_args = parser.parse_args()

    # Invoke the handler for this subcommand
    {
        'start': start,
        'stop': stop,
        'attach': attach,
    }[parsed_args.command](parsed_args)
