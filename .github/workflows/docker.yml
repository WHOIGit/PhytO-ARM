name: Build ROS container

on:
  pull_request:
    paths:
      - "ros/**"
  push:
    paths:
      - "ros/**"

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      # For multi-platform builds
      # https://github.com/docker/build-push-action/blob/master/docs/advanced/multi-platform.md
      - uses: docker/setup-qemu-action@v1
      - uses: docker/setup-buildx-action@v1

      - name: Initialize
        id: init
        run: |
          # Determine whether to push to Docker Hub based on the event type
          case "${{ github.event_name }}" in
            push)
              DOCKER_PUSH=true ;;
            *)
              DOCKER_PUSH=false ;;
          esac

          # Map git ref branch or tag name to Docker tag version
          case "${{ github.ref }}" in
            # Do not push upstream branches and tags to Docker Hub
            refs/heads/upstream/*|refs/tags/upstream/*)
              DOCKER_PUSH=false ;;

            # Do not push pull request branches
            refs/pulls/*)
              DOCKER_PUSH=false ;;

            refs/heads/master)
              DOCKER_TAG=latest ;;
            refs/heads/*|refs/tags/*)
              DOCKER_TAG="$(echo "$GITHUB_REF" | cut -d / -f 3- | \
                sed -e 's,/,-,g')" ;;
          esac

          # Record git source and revision
          GIT_SOURCE=$(git config --get remote.origin.url)
          GIT_REVISION=$(git rev-parse HEAD)$(git diff --quiet || echo "-dirty")

          echo ::set-output name=docker_push::$DOCKER_PUSH
          echo ::set-output name=docker_repo::whoi/$(basename "${{ github.repository }}" | tr A-Z a-z)
          echo ::set-output name=docker_tag::$DOCKER_TAG
          echo ::set-output name=docker_platforms::linux/amd64,linux/arm64
          echo ::set-output name=git_source::$GIT_SOURCE
          echo ::set-output name=git_revision::$GIT_REVISION

      - name: Log into registry
        if: steps.init.outputs.docker_push == 'true'
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_HUB_USER }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      # Enable Docker layer caching in the GitHub Actions cache.
      #
      # https://evilmartians.com/chronicles/build-images-on-github-actions-with-docker-layer-caching
      - name: Cache Docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-multi-buildx-${{ github.sha }}
          restore-keys: ${{ runner.os }}-multi-buildx

      # Pull the previous images from the registry, which helps to avoid
      # invalidating lower layers with updated apt dependencies that then have
      # to be re-downloaded on our bandwidth-constrained devices.
      #
      # This means our images can get stale, but we can always manually rebuild.
      - name: Pull existing images
        shell: bash
        run: |
          TAGS=("${{ steps.init.outputs.docker_tag }}" latest)
          IFS=, read -a PLATFORMS \
            <<< "${{ steps.init.outputs.docker_platforms }}"

          for TAG in "${TAGS[@]}"; do
            for PLATFORM in "${PLATFORMS[@]}"; do
              docker pull --platform "$PLATFORM" \
                "${{ steps.init.outputs.docker_repo }}:$TAG" || true
            done
          done

      - name: Build (and optionally push)
        uses: docker/build-push-action@v2
        with:
          context: ./ros/
          platforms: ${{ steps.init.outputs.docker_platforms }}
          push: ${{ steps.init.outputs.docker_push }}
          tags: ${{ steps.init.outputs.docker_repo }}:${{ steps.init.outputs.docker_tag }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,mode=max,dest=/tmp/.buildx-cache-new
          build-args: |
            GIT_SOURCE=${{ steps.init.outputs.git_source }}
            GIT_REVISION=${{ steps.init.outputs.git_revision }}

      - name: Update cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
